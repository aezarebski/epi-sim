{-# LANGUAGE GADTs #-}

-- |
-- Module: Epidemic.Data.Time
-- Copyright: (c) 2021 Alexander E. Zarebski
-- License: MIT
--
-- Maintainer: Alexander E. Zarebski <aezarebski@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- This module provides some types and functions for working with simulations.
-- The 'TerminationHandler' type is used to control early termination of a
-- simulation. The use case of this is that you can terminate a simulation once
-- it reaches a state specified by a predicate. If this occurs then the
-- simulation is terminated and a summary function is applied to the simulation
-- and this value is returned. This is particularly useful if you want to
-- terminate simulations that have exploded and threaten to eat up all the
-- memory on your machine.

module Epidemic.Data.Simulation
  ( SimulationConfiguration(..)
  , SimulationState(..)
  , SimulationRandEvent(..)
  , TerminationHandler(..)
  , genIOFromFixed
  , genIOFromWord32
  , genIOFromSystem
  ) where

import qualified Data.Vector.Unboxed       as Unboxed
import           Epidemic.Data.Events
import           Epidemic.Data.Parameter
import           Epidemic.Data.Population
import           Epidemic.Data.Time       (AbsoluteTime (..), TimeDelta (..))
import           GHC.Word                  (Word32)
import           System.Random.MWC         (GenIO, create, createSystemRandom,
                                            initialize)

data SimulationConfiguration r p s =
  SimulationConfiguration
    { -- | The event rates
      scRates           :: r
      -- | The population
    , scPopulation      :: p
      -- | A new identifier
    , scNewIdentifier   :: Identifier
      -- | The absolute time at which the simulation starts
    , scStartTime       :: AbsoluteTime
      -- | The duration of the simulation until it stops
    , scSimDuration     :: TimeDelta
      -- | The simulation terminates if this predicate is not satisfied
    , scTerminationHandler :: Maybe (TerminationHandler p s)
      -- | The simulation requires at least two sequenced samples
    , scRequireCherry   :: Bool
    }

-- | Either there is a valid simulation state which contains a sequence of
-- epidemic events along with the time and population or, if the simulation has
-- terminated early there is another value to indicate that along with a value
-- which can be used to indicate why the simulation was terminated early.
data SimulationState b c
  = SimulationState (AbsoluteTime, [EpidemicEvent], b, Identifier)
  | TerminatedSimulation (Maybe c)
  deriving (Eq, Show)

data SimulationRandEvent a b where
  SimulationRandEvent
    :: (ModelParameters a b, Population b)
    => (a
    -> AbsoluteTime
    -> b
    -> Identifier
    -> GenIO
    -> IO (AbsoluteTime, EpidemicEvent, b, Identifier))
    -> SimulationRandEvent a b

-- | Check if a simulation should be terminated and if it should be terminated,
-- then compute a summary explaining why. The first function is used to
-- determine whether the population has entered a state which requires the
-- simulation to terminate early and the second can be use to write a summary of
-- the events that led to the termination.
data TerminationHandler b c where
  TerminationHandler
    :: Population b
    => (b -> Bool)
    -> ([EpidemicEvent] -> c)
    -> TerminationHandler b c

-- | A PRNG seed based on the given number. This is the best choice for
-- reproducible simulations.
genIOFromWord32 :: Word32 -> IO GenIO
genIOFromWord32 seed = initialize (Unboxed.fromList [seed])

-- | A PRNG seed generated by the system's random number generator.
genIOFromSystem :: IO GenIO
genIOFromSystem = createSystemRandom

-- | A PRNG seed which is hard coded into @mwc-random@.
genIOFromFixed :: IO GenIO
genIOFromFixed = create
